---
title: "Programación Funcional en R"
subtitle: "Introducción a la Programación"
format: 
    live-revealjs: 
        scrollable: true
webr:
    packages: 
        - dplyr
        - purrr
# pyodide: 
#     packages: 
#         - scikit-learn
#         - pandas
#         - matplotlib
#         - seaborn
#         - statsmodels
engine: knitr
---

{{< include ../_extensions/r-wasm/live/_knitr.qmd >}}

## Introducción

- Si ya entendiste los conceptos básicos de programación, es hora de explorar la programación funcional en R.
- A diferencia de los ejercicios que realizamos en las lecciones pasadas, veras que en R tenemos librerías que facilitan la programación funcional.


## Estructuras de Control

- Además de las funciones, las estructuras de control son fundamentales en la programación funcional. En R, puedes usar las funciones `if`, `ifelse()`, que son similares a los casos que vimos con el robot Karel.
- R también facilita el uso de estas estructuras de control con sus paquetes y funciones integradas.


## Sintaxis Básica
Recuerda como se ve la sintaxis básica de un condicional en R:

```{webr}
:| eval: false

# Condicional simple
if (condición) {
  # Código que se ejecuta si la condición es TRUE
}

# Condicional con 'else'
if (condición) {
  # Código si la condición es TRUE
} else {
  # Código si la condición es FALSE
}

# Condicional con 'else if'
if (condición1) {
  # Código si condición1 es TRUE
} else if (condición2) {
  # Código si condición2 es TRUE
} else {
  # Código si ninguna condición es TRUE
}

```

## Contar valores únicos

- Una tarea común en análisis de datos es contar los valores únicos en un vector o columna de un data frame.
- En lugar de usar bucles, podemos usar la función `count()` de `dplyr` para contar los valores únicos en un vector.

```{webr}	
library(dplyr)

starwars %>% count(species)

```

##

- podemos agregar el argumento `sort = TRUE` para ordenar los resultados por frecuencia.

```{webr}
starwars %>% count(species, sort = TRUE)

```

##

Podemos evaluar más de una variable a la vez, por ejemplo, para contar los valores únicos de dos variables, `sex` y `gender`, podemos hacer lo siguiente:

```{webr}	

starwars %>% count(sex, gender, sort = TRUE)

```

## group_by() 
- Si queremos contar los valores únicos de una variable en función de otra variable, podemos usar la función `group_by()` de `dplyr`.
- Es decir, agrupamos los datos por una variable y luego contamos los valores únicos de otra variable.

```{webr}
starwars %>%
  group_by(species) %>%
  count(sex, sort = TRUE)

```

## mutate() 

- Si queremos crear una nueva variable, usamos la función `mutate()` de `dplyr`.
- Por ejemplo, podemos crear una nueva variable que indique si un personaje es humano o no.

```{webr}
starwars %>%
  mutate(is_human = ifelse(species == "Human", "Yes", "No")) %>%
  select(name, species, is_human)

```

## across()

- La función `across()` de `dplyr` nos permite aplicar una función a múltiples columnas de un data frame.
- Por ejemplo, podemos calcular la media de las variables numéricas en un data frame.
- En este caso, usamos la función `across()` para seleccionar todas las columnas numéricas y luego aplicamos la función `mean()` a cada una de ellas.

```{webr}
starwars %>%
  select_if(is.numeric) %>%
  summarise(across(everything(), mean, na.rm = TRUE))

```

```{webr}
# A named list of functions
iris %>%
  group_by(Species) %>%
  summarise(across(starts_with("Sepal"), list(mean = mean, sd = sd)))

```

## pull()

- La función `pull()` de `dplyr` nos permite extraer una columna de un data frame como un vector.

```{webr}
iris %>%
  pull(Sepal.Length)

```

## case_when()

- La función `case_when()` de `dplyr` es útil para realizar múltiples comparaciones y asignaciones en un data frame.
- Por ejemplo, podemos crear una nueva variable que indique si una flor es grande, mediana o pequeña en función de su longitud del sépalo.
- La función `case_when()` es similar a una serie de declaraciones `ifelse()` anidadas.
- En este caso, usamos `case_when()` para asignar una categoría a cada flor en función de su longitud del sépalo.

```{webr}
iris %>%
  mutate(size = case_when(
    Sepal.Length > 6 ~ "Large",
    Sepal.Length > 5 ~ "Medium",
    TRUE ~ "Small"
  )) %>%
  select(Sepal.Length, size)

```


- Un paquete muy popular para la programación funcional en R es `purrr`, que ofrece un conjunto de herramientas para trabajar con funciones de manera más efectiva.

![](https://purrr.tidyverse.org/logo.png)

## 

Primero, carga el paquete `purrr` para comenzar a explorar la programación funcional en R. recuerda que es parte del `tidyverse`, por lo que si ya has instalado el tidyverse, no necesitas instalarlo nuevamente.

```{webr}
# Cargar el paquete purrr
library(purrr)

```

##

- Ahora, vamos a crear una función simple que calcule el cuadrado de un número. Luego, usaremos la función `map()` de `purrr` para aplicar esta función a cada elemento de una lista de números.
- La función `map()` remplaza el uso de bucles `for` y `while` en la programación funcional, lo que facilita la aplicación de funciones a múltiples elementos de una lista o vector.


```{webr}

# Función simple pura: cuadrado de un número
cuadrado <- function(x) {
  return(x * x)
}

# Programación funcional usando map de purrr
# Aplicar una función a cada elemento de una lista o vector
numeros <- list(1, 2, 3, 4, 5)
numeros_cuadrados <- map(numeros, cuadrado)
print(numeros_cuadrados)

```

## Ejercicio:

- Crea una función pura que convierta la temperatura de Celsius a Fahrenheit y aplícala a un vector de temperaturas.
- La función para convertir de Celsius a Fahrenheit es: `F = (C * 9/5) + 32`.
- `map_dbl()` es una versión de `map()` que devuelve un vector numérico en lugar de una lista.

```{webr}

celsius_a_fahrenheit <- function(temp_c) {
  return((temp_c * 9/5) + 32)
}

# Aplicar la función al vector de temperaturas
temperaturas_celsius <- c(0, 100, 37)
temperaturas_fahrenheit <- map_dbl(temperaturas_celsius, celsius_a_fahrenheit)
print(temperaturas_fahrenheit)


```




## Reflexión


Reflexión

    ¿En qué situaciones te ves utilizando estructuras de control en tus análisis de datos?
    Prueba a modificar los ejemplos para que realicen tareas más específicas relacionadas con tu campo de estudio.

Esta lección te proporciona las bases para controlar mejor la lógica y flujo de tus programas en R, complementando otros paradigmas de programación disponibles en el lenguaje.