---
title: "Programación Funcional en R"
subtitle: "Introducción a la Programación"
format: 
    live-revealjs: 
        scrollable: true
webr:
    packages: 
        - dplyr
        - purrr
# pyodide: 
#     packages: 
#         - scikit-learn
#         - pandas
#         - matplotlib
#         - seaborn
#         - statsmodels
engine: knitr
---

{{< include ../_extensions/r-wasm/live/_knitr.qmd >}}

## Introducción

La programación funcional es un paradigma que trata la computación como la evaluación de funciones matemáticas y evita cambiar estados y datos mutables. En R, donde las funciones son elementos fundamentales del lenguaje, este enfoque permite escribir código más claro, modular y reutilizable.

---

## Principios de la Programación Funcional



    Funciones como Ciudadanos de Primera Clase: En R, las funciones son tratadas como objetos. Puedes asignarlas a variables, pasarlas como argumentos a otras funciones, y devolverlas desde funciones.

    Funciones Puras: Estas son funciones que, dada la misma entrada, siempre devuelven la misma salida y no tienen efectos colaterales —es decir, no afectan el estado fuera de la función.

    Inmutabilidad: Evita modificar datos directamente. En su lugar, crea nuevas estructuras de datos.

    Composición de Funciones: Combinar funciones simples para construir operaciones más complejas es una práctica común en la programación funcional.


---

## Herramientas de Programación Funcional en R

R tiene varias funciones y paquetes que facilitan la programación funcional, destacando el paquete purrr, que ofrece un conjunto de herramientas para trabajar con funciones de manera más efectiva.
Ejemplo Práctico

Para ilustrar estos conceptos, usaremos el conjunto de datos mtcars nuevamente:

```{webr}
# Cargar el paquete purrr
library(purrr)

# Función simple pura: cuadrado de un número
cuadrado <- function(x) {
  return(x * x)
}

# Programación funcional usando map de purrr
# Aplicar una función a cada elemento de una lista o vector
numeros <- list(1, 2, 3, 4, 5)
numeros_cuadrados <- map(numeros, cuadrado)
print(numeros_cuadrados)

# Usando funciones anónimas para transformar elementos
doble <- map_dbl(numeros, function(x) x * 2)
print(doble)

# Ejemplo de composición de funciones usando pipe ( %>% )
# Calcular el promedio y desviación estándar de los caballos de fuerza
mtcars %>%
  transmute(hp_doble = hp * 2) %>%
  summarize(promedio_hp = mean(hp_doble), sd_hp = sd(hp_doble)) %>%
  print()


```

## Ejercicio: Aplicación de Conceptos de Programación Funcional



    Usa map para calcular el logaritmo natural (log()) de cada elemento en una lista de números.
    Crea una función pura que convierta la temperatura de Celsius a Fahrenheit y aplícala a un vector de temperaturas.
    Usa la canalización (pipe) para filtrar el conjunto de datos mtcars para coches con más de 100 caballos de fuerza, y después calcula el promedio de mpg de estos coches.

Código del Ejercicio:

Código del Ejercicio:

```{webr}
# Solución del Ejercicio

# 1. Usar map para calcular logaritmos
numeros <- list(1, 10, 100, 1000)
log_numeros <- map_dbl(numeros, log)
print(log_numeros)

# 2. Función pura para conversión de temperatura
celsius_a_fahrenheit <- function(temp_c) {
  return((temp_c * 9/5) + 32)
}

# Aplicar la función al vector de temperaturas
temperaturas_celsius <- c(0, 100, 37)
temperaturas_fahrenheit <- map_dbl(temperaturas_celsius, celsius_a_fahrenheit)
print(temperaturas_fahrenheit)

# 3. Usar chaining (pipe) en mtcars
mtcars %>%
  filter(hp > 100) %>%
  summarize(promedio_mpg = mean(mpg)) %>%
  print()

```

## Estructuras de Control

Además de las funciones, las estructuras de control son fundamentales en la programación funcional. En R, puedes usar las funciones `ifelse()`, `case_when()` y `map_if()` para controlar el flujo de ejecución de tu código.

En programación, las estructuras de control nos permiten gestionar el flujo de ejecución de un programa. Aunque R es conocido por su enfoque hacia la programación funcional, comprender las estructuras de control como los bucles y las sentencias condicionales es esencial para realizar tareas específicas donde el control detallado del flujo es necesario.
Sentencias Condicionales: if, else if y else

Las sentencias condicionales se utilizan para ejecutar ciertas porciones de código solo si se cumple una condición específica.


## Sintaxis Básica


```{webr}
:| eval: false

# Condicional simple
if (condición) {
  # Código que se ejecuta si la condición es TRUE
}

# Condicional con 'else'
if (condición) {
  # Código si la condición es TRUE
} else {
  # Código si la condición es FALSE
}

# Condicional con 'else if'
if (condición1) {
  # Código si condición1 es TRUE
} else if (condición2) {
  # Código si condición2 es TRUE
} else {
  # Código si ninguna condición es TRUE
}

```

## Ejemplo: Determinar si un número es positivo, negativo o cero.

```{webr}

numero <- 5

if (numero > 0) {
  print("El número es positivo.")
} else if (numero < 0) {
  print("El número es negativo.")
} else {
  print("El número es cero.")
}

```

## Bucles: for y while

Los bucles permiten repetir una secuencia de código varias veces.

Bucle for: Ejecuta un bloque de código para cada elemento en una secuencia.

```{webr}	

# Sintaxis básica de 'for'
for (elemento in secuencia) {
  # Código que se ejecuta en cada iteración
}

# Ejemplo: Imprimir números del 1 al 5
for (i in 1:5) {
  print(i)
}

```

## Bucle while

Ejecuta un bloque de código mientras una condición es TRUE.

```{webr}
#| eval: false

# Sintaxis básica de 'while'
while (condición) {
  # Código que se ejecuta mientras la condición es TRUE
}
```

```{webr}
# Ejemplo: Imprimir números del 1 al 5
contador <- 1
while (contador <= 5) {
  print(contador)
  contador <- contador + 1
}

```

## Ejercicio: Uso de Estructuras de Control

    Usa un bucle for para recorrer los números del 1 al 10 y mostrar si son pares o impares.
    Usa un while para sumar números del 1 al 10.
    Usa una estructura condicional para evaluar un número dado y clasificarlo como "Bajo", "Medio" o "Alto", según su valor.

Código del Ejercicio:

```{webr}

# 1. Bucle 'for' para determinar si un número es par o impar
for (i in 1:10) {
  if (i %% 2 == 0) {
    print(paste(i, "es par."))
  } else {
    print(paste(i, "es impar."))
  }
}

# 2. Bucle 'while' para sumar números del 1 al 10
suma <- 0
contador <- 1
while (contador <= 10) {
  suma <- suma + contador
  contador <- contador + 1
}
print(paste("La suma es:", suma))

# 3. Estructura condicional para clasificar un número
valor <- 15
if (valor < 10) {
  print("El número es Bajo.")
} else if (valor <= 20) {
  print("El número es Medio.")
} else {
  print("El número es Alto.")
}

```

---


## Reflexión


Reflexión

    ¿En qué situaciones te ves utilizando estructuras de control en tus análisis de datos?
    Prueba a modificar los ejemplos para que realicen tareas más específicas relacionadas con tu campo de estudio.

Esta lección te proporciona las bases para controlar mejor la lógica y flujo de tus programas en R, complementando otros paradigmas de programación disponibles en el lenguaje.